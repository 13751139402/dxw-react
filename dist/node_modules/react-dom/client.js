(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.client = global.client || {}, global.client.js = factory()));
})(this, (function () { 'use strict';

	const FunctionComponent = 0; // ‌函数组件
	const HostRoot = 3; // ‌宿主根节点
	const HostComponent = 5; // 宿主组件,平台原生组件,比如div,p,span等等
	const HostText = 6; // 文本组件

	const NoFlags = 0b0000000;
	const Placement = 0b0000001;
	const Update = 0b0000010;
	const ChildDeletion = 0b0000100;
	// 代表了commit-mutation阶段需要执行的操作，也就是说当前fiber的subtreeFlags或flags中包含了MutationMask中指定的flags,就代表需要执行mutation
	const MutationMask = Placement | Update | ChildDeletion;

	class FiberNode {
	    type;
	    tag;
	    pendingProps;
	    key;
	    stateNode;
	    ref;
	    return;
	    sibling;
	    child;
	    index;
	    memoizedProps;
	    memoizedState; // 更新完之后的state
	    alternate;
	    flags;
	    subtreeFlags; // 代表子树中的flags
	    updateQueue;
	    constructor(tag, pendingProps, key) {
	        // 实例
	        this.tag = tag;
	        this.key = key;
	        // HostComponent <div> div Dom
	        this.stateNode = null;
	        // FunctionComponent ()=>{}
	        this.type = null;
	        // 构成树状结构
	        this.return = null;
	        this.sibling = null;
	        this.child = null;
	        this.index = 0;
	        this.ref = null;
	        // 作为工作单元
	        this.pendingProps = pendingProps; // 刚开始工作的state
	        this.memoizedProps = null; // 工作完成的state
	        this.updateQueue = null;
	        this.memoizedState = null;
	        this.alternate = null;
	        // 副作用
	        this.flags = NoFlags;
	        this.subtreeFlags = NoFlags;
	    }
	}
	class FiberRootNode {
	    container;
	    current;
	    finishWork;
	    constructor(container, hostRootFiber) {
	        this.container = container;
	        // FiberRootNode在创建之初.current就指向了hostRootFiber
	        this.current = hostRootFiber;
	        hostRootFiber.stateNode = this;
	        this.finishWork = null;
	    }
	}
	const createWorkInProgress = (current, pendingProps) => {
	    let wip = current.alternate;
	    if (wip === null) {
	        // mount
	        // mount时没有wip,遂创建
	        wip = new FiberNode(current.tag, pendingProps, current.key);
	        wip.type = current.type;
	        wip.stateNode = current.stateNode;
	        wip.alternate = current;
	        current.alternate = wip;
	    }
	    else {
	        // update
	        wip.pendingProps = pendingProps;
	        // 清除副作用，因为副作用可能是上一次渲染遗留的
	        wip.flags = NoFlags;
	        wip.subtreeFlags = NoFlags;
	    }
	    wip.type = current.type;
	    wip.updateQueue = current.updateQueue;
	    wip.child = current.child;
	    wip.memoizedProps = current.memoizedProps;
	    wip.memoizedState = current.memoizedState;
	    return wip;
	};
	function createFiberFormElement(element) {
	    const { type, key, props } = element;
	    let fiberTag = FunctionComponent;
	    if (typeof type === 'string') {
	        // <div/> type: 'div'
	        fiberTag = HostComponent;
	    }
	    else if (typeof type !== 'function' && true) {
	        console.warn('未定义的type类型', element);
	    }
	    const fiber = new FiberNode(fiberTag, props, key);
	    fiber.type = type;
	    return fiber;
	}

	// 更新对应的数据结构update
	const createUpdate = (action) => {
	    return {
	        action
	    };
	};
	// 保存update的数据结构updateQueue
	const createUpdateQueue = () => {
	    return {
	        // shared之所以是对象是因为能在currentFiber和workInProgress中共用同一个对象
	        shared: {
	            pending: null
	        }
	    };
	};
	// 将update插入到updateQueue中
	const enqueueUpdate = (updateQueue, update) => {
	    updateQueue.shared.pending = update;
	};
	// 如何消费updateQueue
	// 基于一个基础数据baseState以及pendingUpdate,经过计算得到memoizedState
	const processUpdateQueue = (baseState, pendingUpdate // setState的传入参数
	) => {
	    const result = {
	        memoizedState: baseState
	    };
	    if (pendingUpdate !== null) {
	        const action = pendingUpdate.action;
	        if (action instanceof Function) {
	            // baseState 1 update (x)=>4x -> memoizedState 4
	            result.memoizedState = action(baseState);
	        }
	        else {
	            // baseState 1 update 2 -> memoizedState 2
	            result.memoizedState = action;
	        }
	    }
	    return result;
	};

	// ReactSymbols: 为了防止滥用ReactElement,给ReactElement定义一个独一无二的值
	const supportSymbol = typeof Symbol === 'function' && Symbol.for;
	const REACT_ELEMENT_TYPE = supportSymbol
	    ? Symbol.for('react.element')
	    : 0xeac7;

	function ChildReconciler(shouldTrackEffects) {
	    const reconcilerSingleElement = (returnFiber, // 父级fiber
	    currentFiber, element) => {
	        // 根据element创建fiber
	        const fiber = createFiberFormElement(element);
	        fiber.return = returnFiber;
	        return fiber;
	    };
	    const reconcilerSingleTextNode = (returnFiber, // 父级fiber
	    currentFiber, content) => {
	        // 根据element创建fiber
	        const fiber = new FiberNode(HostText, { content }, null);
	        fiber.return = returnFiber;
	        return fiber;
	    };
	    function placeSingleChild(fiber) {
	        // 需要标记flags且没有current fiber的情况下才标记Placement
	        if (shouldTrackEffects && fiber.alternate === null) {
	            fiber.flags |= Placement;
	        }
	        return fiber;
	    }
	    return function reconcilerChildFibers(returnFiber, currentFiber, newChild) {
	        // 判断当前fiber的类型
	        if (typeof newChild === 'object' && newChild !== null) {
	            switch (newChild.$$typeof) {
	                case REACT_ELEMENT_TYPE:
	                    return placeSingleChild(reconcilerSingleElement(returnFiber, currentFiber, newChild));
	                default:
	                    {
	                        console.warn('未实现的reconcile类型', newChild);
	                    }
	                    break;
	            }
	        }
	        // TODO 多节点的情况 ul > li*3
	        // HostText
	        if (typeof newChild === 'string' || typeof newChild === 'number') {
	            return placeSingleChild(reconcilerSingleTextNode(returnFiber, currentFiber, newChild));
	        }
	        {
	            console.warn('未实现的reconcile类型', newChild);
	        }
	        // return fiberNode
	        return null;
	    };
	}
	// reconcilerChildFibers需要添加flags
	const reconcilerChildFibers = ChildReconciler(true);
	// 增加优化策略：mountChildFibers不需要添加placement flags
	// 依靠本就有的hostRootFiber这个placement flags单次插入就够了
	// 将已经离屏构建好的整颗dom树插入到页面中
	const mountChildFibers = ChildReconciler(false);

	// 递归中的递阶段
	// 创建wip fibers
	const beginWork = (wip) => {
	    // 比较，返回子FiberNode
	    switch (wip.tag) {
	        case HostRoot: // HostRootFiber
	            return updateHostRoot(wip);
	        case HostComponent:
	            return updateHostComponent(wip);
	        case HostText:
	            // 文本节点没有children，结束递阶段，开始归阶段
	            return null;
	        default:
	            {
	                console.warn('beginWork未实现的类型');
	            }
	    }
	    return null;
	};
	function updateHostRoot(wip) {
	    const baseState = wip.memoizedState;
	    const updateQueue = wip.updateQueue;
	    const pending = updateQueue.shared.pending; // 参与计算的pending
	    updateQueue.shared.pending = null;
	    const { memoizedState } = processUpdateQueue(baseState, pending); // pending是等待的state
	    // reactDom.createRoot(root).render(<App/>)
	    // render时会创建HostRootFiber,memoizedState对应的就是<App/>这个ReactElement
	    wip.memoizedState = memoizedState;
	    const nextChildren = wip.memoizedState;
	    reconcilerChildren(wip, nextChildren);
	    return wip.child;
	}
	function updateHostComponent(wip) {
	    const nextProps = wip.pendingProps;
	    const nextChildren = nextProps.children; // 子reactElement
	    reconcilerChildren(wip, nextChildren);
	    return wip.child;
	}
	// 子阶段的current fiberNode和子节点的reactElement生成对应的wip fiberNode
	function reconcilerChildren(wip, children) {
	    const current = wip.alternate;
	    if (current !== null) {
	        // update
	        wip.child = reconcilerChildFibers(wip, current?.child, children);
	    }
	    else {
	        // mount
	        wip.child = mountChildFibers(wip, null, children);
	    }
	}

	// export const createInstance = (type: string, props: any): Instance => {
	const createInstance = (type) => {
	    // TODO 处理props
	    const element = document.createElement(type);
	    return element;
	};
	const appendInitialChild = (parent, child) => {
	    parent.appendChild(child);
	};
	const createTextInstance = (content) => {
	    return document.createTextNode(content);
	};
	const appendChildToContainer = appendInitialChild;

	// hostConfig不报错
	// 1.ts：tsconfig.json中配置路径别名path
	// 2.打包流程：react-dom.config.js中配置alias来指定hostConfig别名的路径
	let nextEffect = null;
	const commitMutationEffects = (finishedWork) => {
	    nextEffect = finishedWork;
	    while (nextEffect !== null) {
	        // 向下遍历
	        const child = nextEffect.child;
	        // &:按位与操作，判断某个 flag 是否被包含在flags中
	        // 只要subtreeFlags中包含了MutationMask中指定的flags，就代表子节点有可能存在mutation的操作
	        if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags &&
	            child !== null) {
	            nextEffect = child;
	        }
	        else {
	            // else的情况：
	            // 1.找到底了
	            // 2.当前节点的subtreeFlags不包含MutationMask，但是可能flags包含MutationMask
	            // 接下来就要向上遍历。reconciler阶段已经实现了一次了，就是DFS深度优先遍历，先往下遍历到最深的节点，再往上遍历
	            // 区别在于这里最深的节点不一定是叶子节点，可能是遇到的第一个不存在subtreeFlags的节点
	            up: while (nextEffect !== null) {
	                commitMutationEffectsOnFiber(nextEffect);
	                const sibling = nextEffect.sibling;
	                if (sibling !== null) {
	                    nextEffect = sibling;
	                    break up;
	                }
	                nextEffect = nextEffect.return;
	            }
	        }
	    }
	};
	// 当前finishedWork就是真正存在flags的fiber节点
	const commitMutationEffectsOnFiber = (finishedWork) => {
	    const flags = finishedWork.flags;
	    // 代表fiber节点存在placement操作
	    if ((flags & Placement) !== NoFlags) {
	        commitPlacement(finishedWork);
	        // 这个操作就是将Placement从flags中移除
	        // 分步拆解计算过程：
	        // 第一步：~Placement 对 Placement 取反
	        // Placement 二进制：0000010 → 取反后：1111101（简化为 7 位，实际 JS 是 32 位，不影响核心逻辑）
	        // 第二步：flags & ~Placement
	        //    0000110 (原 flags：Placement + Update)
	        //  & 1111101 (~Placement)
	        //  ---------
	        //    0000100 (结果：只剩 Update 标记，Placement 被移除)
	        finishedWork.flags &= ~Placement;
	    }
	};
	const commitPlacement = (finishedWork) => {
	    // 插入操作需要知道些什么：1.父节点 2.finishedWork对应的DOM节点
	    {
	        console.warn('执行Placement操作', finishedWork);
	    }
	    // parent DOM
	    const hostParent = getHostParent(finishedWork);
	    // 找到finishedWork-DOM append parent-DOM
	    if (hostParent !== null) {
	        appendPlacementNodeIntoContainer(finishedWork, hostParent);
	    }
	};
	// 获得宿主环境的parent节点，应该执行向上遍历的过程
	function getHostParent(fiber) {
	    let parent = fiber.return;
	    while (parent) {
	        const parentTag = parent.tag;
	        // 哪几种情况下parentTag才对应着宿主环境下的父级节点呢
	        if (parentTag === HostComponent) {
	            // 对于HostComponent的fiber节点来说，对应的宿主环境节点是保存在stateNode中的
	            return parent.stateNode;
	        }
	        if (parentTag === HostRoot) {
	            // HostRoot的原生节点保存在哪？
	            return parent.stateNode.container;
	        }
	        parent = parent.return;
	    }
	    {
	        console.warn('未找到host parent', fiber);
	    }
	    return null;
	}
	// 将placement对应的DOM节点append到Container中
	function appendPlacementNodeIntoContainer(finishedWork, hostParent) {
	    // 传进来的finishedWork不一定是HostComponent类型的fiber节点
	    // 通过finishedWork向下遍历找到对应的宿主环境，也就是HostComponent类型的fiber
	    if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
	        appendChildToContainer(finishedWork.stateNode, hostParent);
	        return;
	    }
	    // 递归向下DFS，直到找到第一层HostComponent或者HostText类型的fiber节点，将这个子节点及兄弟节点，都执行appendChildToContainer操作
	    const child = finishedWork.child;
	    if (child !== null) {
	        appendPlacementNodeIntoContainer(child, hostParent);
	        let sibling = child.sibling;
	        while (sibling !== null) {
	            appendPlacementNodeIntoContainer(sibling, hostParent);
	            sibling = sibling.sibling;
	        }
	    }
	}

	// - 对于Host类型fiberNode：构建离屏DOM树
	// - 标记Update flag(TODO)
	const completeWork = (wip) => {
	    // 递归中的归
	    const newProps = wip.pendingProps;
	    const current = wip.alternate;
	    switch (wip.tag) {
	        case HostComponent:
	            if (current !== null && wip.stateNode) ;
	            else {
	                // 1.构建DOM
	                const instance = createInstance(wip.type); // 创建宿主环境的实例，对应浏览器环境的dom
	                // 2.将DOM插入到DOM树中
	                // 因为是归操作，所以instance就是整颗离屏Dom树最考上的一个dom，所以将剩下的离屏dom挂载到instance上
	                appendAllChildren(instance, wip);
	                wip.stateNode = instance;
	            }
	            // 因为completeWork是向上遍历的过程，所以遍历到的每一个节点都是当前最靠上的一个节点
	            // 每次都执行一下bubbleProperties,就能将这个节点的子节点以及子节点的兄弟节点中包含的flags全都冒泡到当前节点的subtreeFlags上
	            // 这样一直冒泡到根节点，那么根节点就能拿到整颗树的subtreeFlags,如果根节点的subtreeFlags包含了副作用，就代表子树中存在插入、更新或者删除等副作用，那么就要向下遍历找到具体的fiber包含了副作用
	            // 如果某颗子树的根节点的subtreeFlags是NoFlags,就代表这颗子树中没有副作用，就不需要继续向下遍历了，可以直接跳过这颗子树
	            // 通过向上遍历的过程中不断冒泡，就能知道当前子树存不存在副作用
	            bubbleProperties(wip);
	            return null;
	        case HostText:
	            if (current !== null && wip.stateNode) ;
	            else {
	                // 1.构建DOM
	                const instance = createTextInstance(newProps.content); // 创建文本节点
	                // 不需要执行appendInitialChild。因为文本节点没有子节点，所以instance就是整颗离屏Dom树最靠上的一个dom，所以直接将instance挂载到wip上就行了
	                // appendInitialChild(instance, wip);
	                wip.stateNode = instance;
	            }
	            bubbleProperties(wip);
	            return null;
	        case HostRoot:
	            bubbleProperties(wip);
	            return null;
	        default:
	            {
	                console.warn('未处理的completeWork情况', wip);
	            }
	    }
	};
	// function A(){
	// 	return <div>111</div>
	// }
	// <h3><A/></h3>
	// 难度在于，对于h3这个dom节点来说，虽然它的子节点是a函数组件，但是对于dom树来说，h3的子节点是div
	// 更复杂的情况在于A还有一个兄弟节点,对于h3来说不仅要插入A的子节点div，同时也要插入A的兄弟节点，另一个A的子节点div
	// <h3>
	// 	<A/>
	// 	<A/>
	// </h3>
	// 我们希望在parent这个节点下插入wip这个节点，但是wip可能不是一个dom节点，所以对于wip我们还需要一个递归的流程
	// 寻找里面的HostComponent或者HostText节点
	// 整个流程就是跟beginWork和completeWork一样的递归流程，DFS
	function appendAllChildren(parent, wip) {
	    let node = wip.child;
	    while (node !== null) {
	        // 如果找到HostComponent和HostText对于着原生组件和文本，可以直接插入
	        if (node.tag === HostComponent || node.tag === HostText) {
	            appendInitialChild(parent, node.stateNode);
	        }
	        else if (node.child !== null) {
	            // child
	            // 复杂的情况:函数组件等没有对应DOM节点的fiberNode,需要继续向下寻找
	            node.child.return = node;
	            node = node.child;
	            continue;
	        }
	        if (node === wip) {
	            return;
	        }
	        // 走到这里就代表往下遍历没找到子节点，也没找到兄弟节点，需要往上归
	        while (node.sibling === null) {
	            if (node.return === null || node.return === wip) {
	                return;
	            }
	            node = node.return;
	        }
	        // sibling
	        node.sibling.return = node.return;
	        node = node.sibling;
	    }
	}
	// flags冒泡
	function bubbleProperties(wip) {
	    let subtreeFlags = NoFlags;
	    let child = wip.child;
	    while (child !== null) {
	        // 只要child存在，就用按位或的操作将child的subtreeFlags附加在当前wip的subtreeFlags上
	        subtreeFlags |= child.subtreeFlags;
	        // 同时还要包含当前child的flags，因为child本身也可能有副作用
	        subtreeFlags |= child.flags;
	        child.return = wip;
	        child = child.sibling;
	    }
	    // 最后将子树的副作用和当前wip的副作用合并在一起，赋值给当前wip的subtreeFlags
	    wip.subtreeFlags |= subtreeFlags;
	}

	// 深度优先遍历
	let workInProgress;
	// 词意：准备新鲜的堆栈
	// 创建wip hostRootFiber
	function prepareFreshStack(root) {
	    // 根据(root.current，即hostRootFiber生成对应的workInProgress（目前只有hostRootFiber）
	    workInProgress = createWorkInProgress(root.current, {});
	}
	function scheduleUpdateOnFiber(fiber) {
	    // TODO 调度功能
	    // 通过当前setState触发的fiber向上遍历找到fiberRootNode
	    const root = markUpdateFormFiberToRoot(fiber);
	    renderRoot(root);
	}
	// 找到FiberRootNode
	function markUpdateFormFiberToRoot(fiber) {
	    let node = fiber;
	    let parent = node.return;
	    while (parent !== null) {
	        node = parent;
	        parent = node.return;
	    }
	    if ((node.tag = HostRoot)) {
	        return node.stateNode;
	    }
	    return null;
	}
	// 从根节点开始diff
	function renderRoot(root) {
	    // 初始化生成wip树的hostRootFiber
	    prepareFreshStack(root);
	    // 更新流程，递归流程
	    // 向下递:beginWork
	    // 向上归:completeWork
	    do {
	        try {
	            workLoop();
	        }
	        catch (e) {
	            {
	                console.warn('workLoop发生错误', e);
	            }
	            workInProgress = null;
	        }
	    } while (true);
	    // root=fiberRootNode, root.current=hostRootFiber, root.current.alternate=wipHostRootFiber
	    // root.current.alternate就是执行workInProgress = createWorkInProgress(root.current, {})的时候创建的hostRootFiber对于的workInProgress Fiber
	    // 当前这颗hostRootFiber下面已经生成了一颗完整的workInProgress树了，并且这棵树中的某些节点还包含了副作用标记
	    const finishWork = root.current.alternate;
	    root.finishWork = finishWork;
	    // wip fiberNode树 树中的flags执行具体的DOM操作
	    commitRoot(root);
	}
	function commitRoot(root) {
	    const finishWork = root.finishWork;
	    if (finishWork === null) {
	        return;
	    }
	    {
	        console.warn('commit阶段开始', finishWork);
	    }
	    // 重置
	    // root.finishWork已经不需要了，因为被保存在finishWork这个变量中了
	    root.finishWork = null;
	    // 判断是否存在3个子阶段需要执行的操作
	    // 需要判断两项 root.flags和root.subtreeFlags
	    // 问：有没有很简便的方式判断commit阶段需要执行呢？
	    // 答：可以用flags-MutationMask来判断，包括子阶段判断是否需要执行，也可以用flags判断
	    const subtreeHasEffect = (finishWork.subtreeFlags & MutationMask) !== NoFlags;
	    const rootHasEffect = (finishWork.flags & MutationMask) !== NoFlags;
	    if (subtreeHasEffect || rootHasEffect) {
	        // beforeMutation
	        // mutation,Flags在此阶段执行
	        commitMutationEffects(finishWork);
	        // fiber树的切换
	        root.current = finishWork;
	        // layout
	    }
	    else {
	        // 即使没有更新发生的话也需要执行这个操作
	        root.current = finishWork;
	    }
	}
	function workLoop() {
	    while (workInProgress !== null) {
	        performUnitOfWork(workInProgress);
	    }
	}
	// 词意：执行工作单元
	function performUnitOfWork(fiber) {
	    const next = beginWork(fiber);
	    // 等待的props变为当前props
	    fiber.memoizedProps = fiber.pendingProps;
	    if (next === null) {
	        // 到底开始“归”阶段
	        completeUnitOfWork(fiber);
	    }
	    else {
	        // 没到底就继续“递”
	        workInProgress = next;
	    }
	}
	function completeUnitOfWork(fiber) {
	    let node = fiber;
	    do {
	        completeWork(node);
	        const sibling = node.sibling; // sibling：包含着子节点和兄弟节点
	        if (sibling !== null) {
	            // 有sibling就结束当前completeUnitOfWork，开始执行sibling的"递"
	            workInProgress = sibling;
	            return;
	        }
	        // "归"完成就回到父级
	        node = node.return;
	        workInProgress = null;
	    } while (node !== null); // 一直"归"到HostRootFiber
	}

	// 创建整个应用的根节点FiberRootNode,并将FiberRootNode和hostRootFiber连接起来
	// reactDom.createRoot(root).render(<App/>)的createRoot函数
	function createContainer(container) {
	    const hostRootFiber = new FiberNode(HostRoot, {}, null);
	    const root = new FiberRootNode(container, hostRootFiber);
	    hostRootFiber.updateQueue = createUpdateQueue();
	    return root;
	}
	// 创建update,并将update enqueue updateQueue中,将[首屏渲染]与[触发机制]连接起来
	// 触发更新的机制是保存在updateQueue中的
	// reactDom.createRoot(root).render(<App/>)的render函数
	function updateContainer(element, root) {
	    const hostRootFiber = root.current;
	    const update = createUpdate(element);
	    // 将update插入updateQueue中以后
	    enqueueUpdate(hostRootFiber.updateQueue, update);
	    // 开始调度
	    scheduleUpdateOnFiber(hostRootFiber);
	    return element;
	}

	// ReactDOM.createRoot(root).render(<App/>);
	// fiberReconciler是不依赖宿主环境的抽象函数，react-dom才是浏览器宿主环境的实现
	function createRoot(container) {
	    const root = createContainer(container);
	    return {
	        render(element) {
	            updateContainer(element, root);
	        }
	    };
	}

	var ReactDOM = /*#__PURE__*/Object.freeze({
		__proto__: null,
		createRoot: createRoot
	});

	return ReactDOM;

}));
